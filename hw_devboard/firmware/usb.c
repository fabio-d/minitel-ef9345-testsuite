#include "usb.h"

#include <autovector.h>
#include <delay.h>
#include <eputils.h>
#include <fx2macros.h>
#include <fx2regs.h>
#include <gpif.h>
#include <setupdat.h>
#include <stdbool.h>

// We don't interact with the GPIF after the initial setup, so we can just use
// the longest sync delay and avoid worrying about differences in clocking.
#define SYNCDELAY SYNCDELAY16

// Set by the SUDAV interrupt handler to ask the main loop to call
// "handle_setupdata" to handle a USB setup packet.
volatile __bit got_sud = false;

// Currently selected alternate interface. We don't really make any use of it
// except from sending it back to the host when requested.
static BYTE selected_altif;

// Note: SUDAV = "SetUp Data AVailable"
void sudav_isr(void) __interrupt(SUDAV_ISR) {
  got_sud = true;
  CLEAR_SUDAV();
}

void usbreset_isr(void) __interrupt(USBRESET_ISR) {
  handle_hispeed(false);
  CLEAR_USBRESET();
}

void hispeed_isr(void) __interrupt(HISPEED_ISR) {
  handle_hispeed(true);
  CLEAR_HISPEED();
}

void disable_all_usb_endpoints(void) {
  EP1INCFG &= ~bmVALID;
  SYNCDELAY;
  EP1OUTCFG &= ~bmVALID;
  SYNCDELAY;
  EP2CFG &= ~bmVALID;
  SYNCDELAY;
  EP6CFG &= ~bmVALID;
  SYNCDELAY;
  EP4CFG &= ~bmVALID;
  SYNCDELAY;
  EP8CFG &= ~bmVALID;
  SYNCDELAY;
}

void unset_all_wordwide_flags(void) {
  EP2FIFOCFG &= ~bmWORDWIDE;
  SYNCDELAY;
  EP4FIFOCFG &= ~bmWORDWIDE;
  SYNCDELAY;
  EP6FIFOCFG &= ~bmWORDWIDE;
  SYNCDELAY;
  EP8FIFOCFG &= ~bmWORDWIDE;
  SYNCDELAY;
}

void start_usb_streaming(void) {
  // Enable the GPIF using the internal 48 MHz clock.
  IFCONFIG = bmIFCLKSRC | bm3048MHZ | bmASYNC | bmIFCFG1;
  SYNCDELAY;

  // Set EP2 as ISO IN, 1024 bytes, quad-buffered.
  EP2CFG = bmVALID | bmDIR | bmTYPE0 | bmSIZE;
  SYNCDELAY;

  // Enable automatic generation of zero-length packets for EP2 if there's not
  // enough data, set maximum number of packets per frame to two.
  EP2ISOINPKTS = 0x82;
  SYNCDELAY;

  RESETFIFO(2);

  // Set AUTOIN to automatically commit a packet every 1024 bytes.
  EP2FIFOCFG = bmAUTOIN;
  SYNCDELAY;
  EP2AUTOINLENH = MSB(1024);
  SYNCDELAY;
  EP2AUTOINLENL = LSB(1024);
  SYNCDELAY;

  // Configure CTL0-3 pins: not tristate and not open-drain.
  GPIFCTLCFG = 0;
  SYNCDELAY;

  // Load our GPIF state machine, which outputs a 12 MHz clock signal on CTL0
  // and samples once per cycle (while CTL0 is low). This results in a 12 MiB/s
  // USB stream, and it's enough to capture all the pixels generated by the
  // video chip (which are emitted at the rate of one per clock cycle in 80
  // columns mode, and one per 1.5 cycles in 40 columns mode).

  // S0 state.
  (&GPIF_WAVE_DATA)[000] = 011; // Next state = S1
  (&GPIF_WAVE_DATA)[010] = 1;   // OPCODE = DP
  (&GPIF_WAVE_DATA)[020] = 0;   // CTL0=0
  (&GPIF_WAVE_DATA)[030] = 0;
  // S1 state.
  (&GPIF_WAVE_DATA)[001] = 022; // Next state = S2
  (&GPIF_WAVE_DATA)[011] = 3;   // OPCODE = DP, DATA (i.e. sample now)
  (&GPIF_WAVE_DATA)[021] = 0;   // CTL0=0 (same as S0)
  (&GPIF_WAVE_DATA)[031] = 0;
  // S2 state.
  (&GPIF_WAVE_DATA)[002] = 033; // Next state = S3
  (&GPIF_WAVE_DATA)[012] = 1;   // OPCODE = DP
  (&GPIF_WAVE_DATA)[022] = 1;   // CTL0=1
  (&GPIF_WAVE_DATA)[032] = 0;
  // S3 state.
  (&GPIF_WAVE_DATA)[003] = 000; // Next state = S0
  (&GPIF_WAVE_DATA)[013] = 1;   // OPCODE = DP
  (&GPIF_WAVE_DATA)[023] = 1;   // CTL0=1 (same as S2)
  (&GPIF_WAVE_DATA)[033] = 0;

  // Start the state machine, setting the transaction count to one is enough,
  // because our state machine never ends.
  gpif_set_tc16(1);
  gpif_fifo_read(GPIF_EP2);
}

// Resets the data toggle bit. Called every time the configuration of the
// affected endpoint changes.
static void reset_data_toggle(void) {
#pragma save
#pragma disable_warning 110 // disable false positive within RESETTOGGLE.
  RESETTOGGLE(0x81);
  RESETTOGGLE(0x82);
#pragma restore
}

BOOL handle_get_descriptor(void) {
  return false;
}

BOOL handle_get_interface(BYTE ifc, BYTE *alt_ifc) {
  (void)ifc;
  *alt_ifc = selected_altif;
  return true;
}

BOOL handle_set_interface(BYTE ifc, BYTE alt_ifc) {
  (void)ifc;

  if (alt_ifc > 1) {
    return false;
  }

  selected_altif = alt_ifc;
  reset_data_toggle();
  return true;
}

BYTE handle_get_configuration(void) {
  return 1;
}

BOOL handle_set_configuration(BYTE cfg) {
  if (cfg != 1) {
    return false;
  }

  reset_data_toggle();
  return true;
}
